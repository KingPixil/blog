<!doctype html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Inventing Monads | Kabir Shah's blog on design, the web, servers, databases, systems, algorithms, artificial intelligence, cryptography, and ideas."><meta name="author" content="Kabir Shah"><title>Inventing Monads | Kabir Shah</title><link rel="shortcut icon" href="../img/logo-fill.png"/><link href="https://fonts.googleapis.com/css?family=Fenix|Inconsolata" rel="stylesheet"><link rel="stylesheet" type="text/css" href="../css/lib/grain.css"/><link rel="stylesheet" type="text/css" href="../css/post.css"/><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-70792533-7","auto"),ga("send","pageview")</script></head><body><div class="container"><a href="../" id="back"><svg width="37" height="24" viewBox="0 0 37 24" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>Arrow</title><path id="back-arrow" d="M36.0607 1.06066c.5857-.585786.5857-1.535534 0-2.12132l-9.546-9.54594c-.5858-.5858-1.5355-.5858-2.1213 0-.5858.5858-.5858 1.53553 0 2.12132L32.8787 0l-8.4853 8.48528c-.5858.58579-.5858 1.53552 0 2.12132.5858.5858 1.5355.5858 2.1213 0l9.546-9.54594zM0 1.5h35v-3H0v3z" transform="rotate(180 18.5 6)" fill="#888"/></svg></a><h1 class="post-title">Inventing Monads</h1><h3 class="post-date">August 1, 2019</h3><p>Monads are an esoteric concept to many, resulting in hundreds of tutorials, guides, and examples attempting to explain them. Curious developers might look into them only to find the classic answer, &quot;Monads are monoids in the category of endofunctors&quot;. In the end, they&#39;re just another abstraction to help deal with repetitive patterns in functional code.</p><p>This guide will use JavaScript instead of a pure functional programming language (e.g. Haskell) to make things more approachable for developers accustomed to imperative languages. It will, however, assume you have basic knowledge of functional programming, including currying and lambdas.</p><p>Think of monads as a way to overload a semicolon. It might sound a little crazy at first, but imagine being able to override the semicolon to reduce boilerplate in specific code blocks. That&#39;s basically how monads are used in practice.</p><h2 id="blocks">Blocks</h2><p>First, blocks of code wrapped in curly braces can usually be transformed into function calls. Being explicit about composing functions in this way can help clarify how exactly monads can modify the flow of a program.</p><p>For example, the following block of code:</p><pre><code lang="js">{
    <span class="special">const </span><span class="global">id</span> = <span class="method">getId </span>();
    <span class="special">const </span><span class="global">user</span> = <span class="method">getUser </span>(id);
    <span class="special">const </span><span class="global">middleName</span> = <span class="method">getMiddleName </span>(user);
}
</code></pre><p>Can be represented as:</p><pre><code lang="js"><span class="special">const </span><span class="global">middleName</span> = (
    id =&gt; (
        user =&gt; <span class="method">getMiddleName </span>(user)
    ) (<span class="method">getUser </span>(id))
) (<span class="method">getId </span>());
</code></pre><p>It&#39;s a little confusing, but they are equivalent. Functions are called with a space between the name and parenthesis. This is done to simulate calling functions by juxtaposition, and it&#39;s helpful for calling curried functions. This functional version of block syntax is syntactically similar to turning everything inside out, with the last expression in the middle.</p><p>It can be thought of this way:</p><pre><code lang="js">{
    <span class="special">const </span><span class="global">id</span> = <span class="method">getId </span>();

    <span class="comment">// Everything below is a <span class="special">function</span> of <span class="string">&quot;id&quot;</span>.</span>
    <span class="special">const </span><span class="global">user</span> = <span class="method">getUser </span>(id);

    <span class="comment">// Everything below is a <span class="special">function</span> of <span class="string">&quot;user&quot;</span>.</span>
    <span class="special">const </span><span class="global">middleName</span> = <span class="method">getMiddleName </span>(user);
}
</code></pre><h2 id="null-everywhere">Null Everywhere</h2><p>Revisiting the previous example, the code might look like this:</p><pre><code lang="js">{
    <span class="special">const </span><span class="global">id</span> = <span class="method">getId </span>();
    <span class="special">const </span><span class="global">user</span> = <span class="method">getUser </span>(id);
    <span class="special">const </span><span class="global">middleName</span> = <span class="method">getMiddleName </span>(user);
}
</code></pre><p>It&#39;s clean enough, right? Now imagine if <code>id</code> could be <code>null</code>, <code>user</code> could be <code>null</code>, or <code>middleName</code> could be <code>null</code>. The utility functions will all end up looking like this:</p><pre><code lang="js"><span class="comment">// Simulate the fetching of an ID.</span>
<span class="special">const </span><span class="global">getId</span> = () =&gt; {
    <span class="special">const </span><span class="global">random</span> = Math.<span class="method">floor</span>(Math.<span class="method">random</span>() * <span class="global">1000</span>);

    <span class="special">return</span> random &lt; <span class="global">700</span> ? random : <span class="global">null</span>;
};

<span class="comment">// Simulate the fetching of a user.</span>
<span class="special">const </span><span class="global">getUser</span> = id =&gt; {
    <span class="special">if</span> (id === <span class="global">null</span>) {
        <span class="special">return</span> <span class="global">null</span>;
    } <span class="special">else</span> {
        <span class="special">return</span> {
            first: <span class="string">&quot;John&quot;</span>,
            last: <span class="string">&quot;Doe&quot;</span>,
            middle: Math.<span class="method">random</span>() &lt; <span class="global">0.7</span> ? <span class="string">&quot;Bob&quot;</span> : <span class="global">null</span>
        };
    }
};

<span class="comment">// Simulate the fetching of a middle name.</span>
<span class="special">const </span><span class="global">getMiddleName</span> = user =&gt; {
    <span class="special">if</span> (user.middle === <span class="global">null</span>) {
        <span class="special">return</span> <span class="global">null</span>;
    } <span class="special">else</span> {
        <span class="special">return</span> user.middle;
    }
};
</code></pre><p>Every utility function has to check and handle <code>null</code> values, and has the possibility of returning <code>null</code> as well. But what if it could be checked for automatically? That&#39;s where monads come in.</p><p>Once again, the functional version of the block would look like this:</p><pre><code lang="js"><span class="special">const </span><span class="global">middleName</span> = (
    id =&gt; (
        user =&gt; <span class="method">getMiddleName </span>(user)
    ) (<span class="method">getUser </span>(id))
) (<span class="method">getId </span>());
</code></pre><p>Looking at this, we can find a pattern: every function takes a nullable value as input and output. Instead of handling <code>null</code> within each function, we can create an <code>apply</code> function that will handle it for us.</p><pre><code lang="js"><span class="special">const </span><span class="global">apply</span> = f =&gt; x =&gt; x === <span class="global">null</span> ? <span class="global">null</span> : <span class="method">f </span>(x);
</code></pre><p>This function takes the next function <code>f</code> along with the value <code>x</code> to pass to it. Since the inputs can be <code>null</code>, it checks and returns <code>null</code> whenever the input is <code>null</code>. If not, it passes <code>x</code> to the next function. Now the code will look like:</p><pre><code lang="js"><span class="special">const </span><span class="global">middleName</span> = <span class="method">apply </span>(
    id =&gt; <span class="method">apply </span>(
        user =&gt; <span class="method">getMiddleName </span>(user)
    ) (<span class="method">getUser </span>(id))
) (<span class="method">getId </span>());
</code></pre><p>This preserves the quality that every function returns a nullable value, but allows them to assume that their input is not <code>null</code>. Before, every function had the same input and output type. Now, the <code>apply</code> function has the same input and output type, but it is free to use its given function however it likes, as long as it keeps the same input and output type. With this, the full code can be written as:</p><pre><code lang="js"><span class="comment">// Simulate the fetching of an ID.</span>
<span class="special">const </span><span class="global">getId</span> = () =&gt; {
    <span class="special">const </span><span class="global">random</span> = Math.<span class="method">floor</span>(Math.<span class="method">random</span>() * <span class="global">1000</span>);

    <span class="special">return</span> random &lt; <span class="global">700</span> ? random : <span class="global">null</span>;
};

<span class="comment">// Simulate the fetching of a user.</span>
<span class="special">const </span><span class="global">getUser</span> = id =&gt; ({
    first: <span class="string">&quot;John&quot;</span>,
    last: <span class="string">&quot;Doe&quot;</span>,
    middle: Math.<span class="method">random</span>() &lt; <span class="global">0.7</span> ? <span class="string">&quot;Bob&quot;</span> : <span class="global">null</span>
});

<span class="comment">// Simulate the fetching of a middle name.</span>
<span class="special">const </span><span class="global">getMiddleName</span> = user =&gt; user.middle;

<span class="comment">// Get the middle name, <span class="special">if</span> it exists.</span>
<span class="special">const </span><span class="global">apply</span> = f =&gt; x =&gt; x === <span class="global">null</span> ? <span class="global">null</span> : <span class="method">f </span>(x);
<span class="special">const </span><span class="global">middleName</span> = <span class="method">apply </span>(
    id =&gt; <span class="method">apply </span>(
        user =&gt; <span class="method">getMiddleName </span>(user)
    ) (<span class="method">getUser </span>(id))
) (<span class="method">getId </span>());

console.<span class="method">log</span>(middleName);
<span class="comment">// <span class="global">49</span>% =&gt; <span class="string">&quot;Bob&quot;</span>, <span class="global">51</span>% =&gt; <span class="global">null</span></span>
</code></pre><h2 id="logging">Logging</h2><p>Keeping the same example, let&#39;s say we want to keep track of log messages. In a functional language, you can&#39;t modify a global variable to keep track of all of the messages. Instead, each function can return an output along with a log message.</p><pre><code lang="js"><span class="special">const </span><span class="global">getId</span> = () =&gt; [<span class="global">7</span>, <span class="string">&quot;Got an id of <span class="global">7</span>.&quot;</span>];
<span class="special">const </span><span class="global">getUser</span> = id =&gt; [{
    first: <span class="string">&quot;John&quot;</span>,
    last: <span class="string">&quot;Doe&quot;</span>,
    middle: <span class="string">&quot;Bob&quot;</span>
}, id[<span class="global">1</span>] + <span class="string">&quot; Got a user with name John Bob Doe.&quot;</span>];
<span class="special">const </span><span class="global">getMiddleName</span> = user =&gt; [user[<span class="global">0</span>].middle, user[<span class="global">1</span>] + <span class="string">&quot; Got the middle name of a user.&quot;</span>];

{
    <span class="special">const </span><span class="global">id</span> = <span class="method">getId </span>();
    <span class="special">const </span><span class="global">user</span> = <span class="method">getUser </span>(id);
    <span class="special">const </span><span class="global">middleName</span> = <span class="method">getMiddleName </span>(user);
}
</code></pre><p>This is messy, and we had to modify the utility functions in order to handle the incoming array input. Instead, we can write the block as functions again, but change the <code>apply</code> function to propagate the log for us. In this case, everything has the same array type <code>[output, log]</code>.</p><pre><code lang="js"><span class="special">const </span><span class="global">apply</span> = f =&gt; x =&gt; {
    <span class="special">const </span><span class="global">result</span> = <span class="method">f </span>(x[<span class="global">0</span>]);
    <span class="special">return</span> [result[<span class="global">0</span>], x[<span class="global">1</span>] + <span class="string">&quot; &quot;</span> + result[<span class="global">1</span>]];
};
</code></pre><p>Since everything has the same array type, we take it as an input. Instead of passing the log to the function though, we only pass the output of the value <code>x[0]</code> to the function <code>f</code>. This function will return its own output and log. We return a new pair with the function output along with the combined logs.</p><p>The full code will then be much simpler, and doesn&#39;t include anything related to the previous log message in the utility functions:</p><pre><code lang="js"><span class="comment">// Get various data from a user.</span>
<span class="special">const </span><span class="global">getId</span> = () =&gt; [<span class="global">7</span>, <span class="string">&quot;Got an id of <span class="global">7</span>.&quot;</span>];
<span class="special">const </span><span class="global">getUser</span> = id =&gt; [{
    first: <span class="string">&quot;John&quot;</span>,
    last: <span class="string">&quot;Doe&quot;</span>,
    middle: <span class="string">&quot;Bob&quot;</span>
}, <span class="string">&quot;Got a user with name John Bob Doe.&quot;</span>];
<span class="special">const </span><span class="global">getMiddleName</span> = user =&gt; [user.middle, <span class="string">&quot;Got the middle name of a user.&quot;</span>];

<span class="comment">// Get the middle name along with logs.</span>
<span class="special">const </span><span class="global">apply</span> = f =&gt; x =&gt; {
    <span class="special">const </span><span class="global">result</span> = <span class="method">f </span>(x[<span class="global">0</span>]);
    <span class="special">return</span> [result[<span class="global">0</span>], x[<span class="global">1</span>] + <span class="string">&quot; &quot;</span> + result[<span class="global">1</span>]];
};
<span class="special">const </span><span class="global">middleName</span> = <span class="method">apply </span>(
    id =&gt; <span class="method">apply </span>(
        user =&gt; <span class="method">getMiddleName </span>(user)
    ) (<span class="method">getUser </span>(id))
) (<span class="method">getId </span>());

console.<span class="method">log</span>(middleName);
<span class="comment">// =&gt; [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Got an id of <span class="global">7</span>. Got a user with name John Bob Doe. Got the middle name of a user.&quot;</span>]</span>
</code></pre><h2 id="global-environment">Global Environment</h2><p>Let&#39;s say we have a global object fetched from somewhere, and it holds data for a user.</p><pre><code lang="js">{
    id: <span class="global">7</span>,
    first: <span class="string">&quot;John&quot;</span>,
    last: <span class="string">&quot;Doe&quot;</span>
}
</code></pre><p>Along with that, we have a calculation based on this environment.</p><pre><code lang="js"><span class="special">const </span><span class="global">getInitials</span> = environment =&gt; environment.first[<span class="global">0</span>] + environment.last[<span class="global">0</span>];
<span class="special">const </span><span class="global">getName</span> = initials =&gt; environment =&gt; <span class="string">`${initials} ${environment.first} ${environment.last}`</span>;
<span class="special">const </span><span class="global">getIdentity</span> = name =&gt; environment =&gt; environment.id.<span class="method">toString</span>() + <span class="string">&quot; &quot;</span> + name;

{
    <span class="special">const </span><span class="global">initials</span> = <span class="method">getInitials </span>(environment);
    <span class="special">const </span><span class="global">name</span> = <span class="method">getName </span>(initials) (environment);
    <span class="special">const </span><span class="global">identity</span> = <span class="method">getIdentity </span>(name) (environment);
}
</code></pre><p>In this case, every single function requires the <code>environment</code> as an input. What if we made that implicit?</p><pre><code lang="js"><span class="special">const </span><span class="global">getInitials</span> = environment =&gt; environment.first[<span class="global">0</span>] + environment.last[<span class="global">0</span>];
<span class="special">const </span><span class="global">getName</span> = initials =&gt; environment =&gt; <span class="string">`${<span class="method">initials </span>(environment)} ${environment.first} ${environment.last}`</span>;
<span class="special">const </span><span class="global">getIdentity</span> = name =&gt; environment =&gt; environment.id.<span class="method">toString</span>() + <span class="string">&quot; &quot;</span> + <span class="method">name </span>(environment);

{
    <span class="special">const </span><span class="global">initials</span> = getInitials;
    <span class="special">const </span><span class="global">name</span> = <span class="method">getName </span>(initials);
    <span class="special">const </span><span class="global">identity</span> = <span class="method">getIdentity </span>(name);
}
</code></pre><p>It looks nicer, but the utility functions had to change. They now have to call their first argument with the environment in order to get their true value. The functional version of the block would look like this:</p><pre><code lang="js"><span class="special">const </span><span class="global">identity</span> = <span class="method">apply </span>(
    initials =&gt; <span class="method">apply </span>(
        name =&gt; <span class="method">getIdentity </span>(name)
    ) (<span class="method">getName </span>(initials))
) (getInitials);
</code></pre><p>Here, every function has a <em>function of the environment</em> as both input and output. What if we kept that property, but the applied function could get the previous value directly? We can change the definition of <code>apply</code>:</p><pre><code lang="js"><span class="special">const </span><span class="global">apply</span> = f =&gt; x =&gt; environment =&gt; <span class="method">f </span>(<span class="method">x </span>(environment)) (environment);
</code></pre><p>It&#39;s a little confusing, but the <code>apply</code> function still has a function of the environment as input and output. It returns a new function that takes the environment as input. In this function, it takes the input value <code>x</code>, which is a function of the environment, and applies it with the environment. This value is fed into <code>f</code>, so that it can expect the actual output of the function without having to worry about passing it the environment. Since <code>f</code> returns yet another function of the environment, it finally applies it with the environment once again.</p><p>It&#39;s a lot of function application, but the key idea is that <code>apply</code> keeps the property that every input and every output is a function of the environment. It just applies the next function with an actual value so it won&#39;t have to worry about the input being a function.</p><p>With that, the final code looks like:</p><pre><code lang="js"><span class="comment">// Utility functions to <span class="special">return</span> calculations based on an environment.</span>
<span class="special">const </span><span class="global">getInitials</span> = environment =&gt; environment.first[<span class="global">0</span>] + environment.last[<span class="global">0</span>];
<span class="special">const </span><span class="global">getName</span> = initials =&gt; environment =&gt; <span class="string">`${initials} ${environment.first} ${environment.last}`</span>;
<span class="special">const </span><span class="global">getIdentity</span> = name =&gt; environment =&gt; environment.id.<span class="method">toString</span>() + <span class="string">&quot; &quot;</span> + name;

<span class="comment">// Get the identity of the environment user.</span>
<span class="special">const </span><span class="global">apply</span> = f =&gt; x =&gt; environment =&gt; <span class="method">f </span>(<span class="method">x </span>(environment)) (environment);
<span class="special">const </span><span class="global">identity</span> = <span class="method">apply </span>(
    initials =&gt; <span class="method">apply </span>(
        name =&gt; <span class="method">getIdentity </span>(name)
    ) (<span class="method">getName </span>(initials))
) (getInitials);

<span class="comment">// Since <span class="string">`identity`</span> is a <span class="special">function</span> of an environment, we can pass it any environment.</span>
console.<span class="method">log</span>(<span class="method">identity </span>({
    id: <span class="global">7</span>,
    first: <span class="string">&quot;John&quot;</span>,
    last: <span class="string">&quot;Doe&quot;</span>
}));
<span class="comment">// =&gt; <span class="global">7</span> JD John Doe</span>
</code></pre><h2 id="passing-state">Passing State</h2><p>Let&#39;s say we have a state for holding the seed of a random number generator.</p><pre><code lang="js"><span class="global">7</span>
</code></pre><p>In pure functional languages, there is no concept of mutation, only pure functions. However, for things like random number generation, there is often a seed that is kept track of as state. It needs to be sent around so that the next number and seed can be generated from it. We can write a block like this:</p><pre><code lang="js"><span class="special">const </span><span class="global">getRandom</span> = state =&gt; {
    <span class="special">const </span><span class="global">result</span> = <span class="global">7</span> * state + <span class="global">7</span>;
    <span class="special">return</span> [result % <span class="global">100</span>, result];
};

<span class="special">const </span><span class="global">getSum</span> = x =&gt; y =&gt; state =&gt; {
    <span class="special">const </span><span class="global">xResult</span> = <span class="method">x </span>(state);
    <span class="special">const </span><span class="global">yResult</span> = <span class="method">y </span>(xResult[<span class="global">1</span>]);
    <span class="special">return</span> [xResult[<span class="global">0</span>] + yResult[<span class="global">0</span>], yResult[<span class="global">1</span>]];
};

{
    <span class="special">const </span><span class="global">random1</span> = getRandom;
    <span class="special">const </span><span class="global">random2</span> = getRandom;
    <span class="special">const </span><span class="global">sum</span> = <span class="method">getSum </span>(random1) (random2);
}
</code></pre><p>In this example, every value is a function of state that returns and output along with new state. It&#39;s not the best code though, because <code>getSum</code> has to call both of its arguments with the state in order to get their value, then it has to correctly manage the latest state and return it. The functional version of the block looks like:</p><pre><code lang="js"><span class="special">const </span><span class="global">random1</span> = getRandom;
<span class="special">const </span><span class="global">random2</span> = getRandom;
<span class="special">const </span><span class="global">sum</span> = <span class="method">getSum </span>(random1) (random2);

<span class="special">const </span><span class="global">sum</span> = <span class="method">apply </span>(
    random1 =&gt; <span class="method">apply </span>(
        random2 =&gt; <span class="method">getSum </span>(random1) (random2)
    ) (getRandom)
) (getRandom);
</code></pre><p>Every function has <em>a function of state that returns and output and new state</em> as its input and output. Instead of having to deal with a function as input, we can change <code>apply</code> to apply the function with an actual value and handle state changes.</p><pre><code lang="js"><span class="special">const </span><span class="global">apply</span> = f =&gt; x =&gt; state =&gt; {
    <span class="special">const </span><span class="global">result</span> = <span class="method">x </span>(state);
    <span class="special">return</span> <span class="method">f </span>(result[<span class="global">0</span>]) (result[<span class="global">1</span>]);
};
</code></pre><p>It&#39;s elegant, but dense. Since the input <code>x</code> and the output of <code>apply</code> are both functions of state, it returns a new function of state. In this function, it first applies the input with the state and stores the <code>result</code>. Now, the next function <code>f</code> is applied with the <em>output</em> portion of the result, so it doesn&#39;t have to worry about the state. <code>f</code> outputs another function of state, so it is called with the <em>state</em> portion of the result in order to get a new output and new state.</p><p>The full code looks like:</p><pre><code lang="js"><span class="comment">// Utility functions <span class="special">for</span> number manipulation.</span>
<span class="special">const </span><span class="global">getRandom</span> = state =&gt; {
    <span class="special">const </span><span class="global">result</span> = <span class="global">7</span> * state + <span class="global">7</span>;
    console.<span class="method">log</span>(<span class="string">&quot;Random number: &quot;</span> + (result % <span class="global">100</span>)); <span class="comment">// Log random numbers <span class="special">for</span> debugging.</span>
    <span class="special">return</span> [result % <span class="global">100</span>, result];
};

<span class="special">const </span><span class="global">getSum</span> = x =&gt; y =&gt; state =&gt; [x + y, state];

<span class="comment">// Generate the sum of two random numbers.</span>
<span class="special">const </span><span class="global">apply</span> = f =&gt; x =&gt; state =&gt; {
    <span class="special">const </span><span class="global">result</span> = <span class="method">x </span>(state);
    <span class="special">return</span> <span class="method">f </span>(result[<span class="global">0</span>]) (result[<span class="global">1</span>]);
};

<span class="special">const </span><span class="global">sum</span> = <span class="method">apply </span>(
    random1 =&gt; <span class="method">apply </span>(
        random2 =&gt; <span class="method">getSum </span>(random1) (random2)
    ) (getRandom)
) (getRandom);

console.<span class="method">log</span>(<span class="method">sum </span>(<span class="global">7</span>));
<span class="comment">// =&gt; Random number: <span class="global">56</span></span>
<span class="comment">// =&gt; Random number: <span class="global">99</span></span>
<span class="comment">// =&gt; [<span class="global">155</span>, <span class="global">399</span>]</span>
</code></pre><h2 id="conclusion">Conclusion</h2><p>TODO</p></div><footer><a href="https://kabir.sh">Portfolio</a> <a href="https://blog.kabir.sh">Blog</a> <a href="https://twitter.com/kbrshah">Twitter</a> <a href="https://github.com/kbrsh">GitHub</a></footer></body></html>