<!doctype html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Inventing Monads | Kabir Shah's blog on design, the web, servers, databases, systems, algorithms, artificial intelligence, cryptography, and ideas."><meta name="author" content="Kabir Shah"><title>Inventing Monads | Kabir Shah</title><link rel="shortcut icon" href="../img/logo-fill.png"/><link rel="alternate" type="application/json" title="Kabir Shah" href="/feed.json"/><link href="https://fonts.googleapis.com/css?family=Fenix|Inconsolata" rel="stylesheet"><link rel="stylesheet" type="text/css" href="../css/lib/grain.css"/><link rel="stylesheet" type="text/css" href="../css/post.css"/><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-70792533-7","auto"),ga("send","pageview")</script></head><body><div class="container"><a href="../" id="back"><svg width="37" height="24" viewBox="0 0 37 24" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>Arrow</title><path id="back-arrow" d="M36.0607 1.06066c.5857-.585786.5857-1.535534 0-2.12132l-9.546-9.54594c-.5858-.5858-1.5355-.5858-2.1213 0-.5858.5858-.5858 1.53553 0 2.12132L32.8787 0l-8.4853 8.48528c-.5858.58579-.5858 1.53552 0 2.12132.5858.5858 1.5355.5858 2.1213 0l9.546-9.54594zM0 1.5h35v-3H0v3z" transform="rotate(180 18.5 6)" fill="#888"/></svg></a><h1 class="post-title">Inventing Monads</h1><h3 class="post-date">August 1, 2019</h3><p>Monads are an esoteric concept to many, resulting in hundreds of tutorials, guides, and examples attempting to explain them. Curious developers might look into them only to find the classic answer, &quot;Monads are monoids in the category of endofunctors&quot;. In the end, they&#39;re just another abstraction to help deal with repetitive patterns in functional code.</p><p>This guide will use JavaScript instead of a pure functional programming language (e.g. Haskell) to make things more approachable for developers accustomed to imperative languages. It will, however, assume you have basic knowledge of functional programming, including currying and lambdas.</p><p>Think of monads as a way to overload a semicolon. It might sound a little crazy at first, but imagine being able to override the semicolon to reduce boilerplate in specific code blocks. That&#39;s basically how monads are used in practice.</p><p>As a final note before we start, I am by no means an expert on this topic. I&#39;m fifteen years old with good knowledge of mostly high school level math, and may have missed some parts. Monads are complex and closely tied with category theory, which is a very abstract and vast branch of mathematics that can be hard to grok. If I missed something, feel free to reach out and let me know â€” I&#39;m always open to learning something new.</p><h2 id="blocks">Blocks</h2><p>First, many languages have a pattern that allows for creating a set of bindings and then a value based on it. In JavaScript, this is accomplished with a self-invoking function. They can also be transformed into a recursive structure of function calls with variable values. Being explicit about composing functions in this way can help clarify how exactly monads can modify the flow of a program.</p><p>For example, the following block of code:</p><pre><code lang="js"><span class="special">const </span><span class="global">middleName</span> = (() =&gt; {
    <span class="special">const </span><span class="global">id</span> = <span class="method">getId </span>();
    <span class="special">const </span><span class="global">user</span> = <span class="method">getUser </span>(id);
    <span class="special">return</span> <span class="method">getMiddleName </span>(user);
})();
</code></pre><p>Can be represented as:</p><pre><code lang="js"><span class="special">const </span><span class="global">apply</span> = x =&gt; f =&gt; <span class="method">f </span>(x);
<span class="special">const </span><span class="global">middleName</span> = <span class="method">apply </span>(<span class="method">getId</span>()) (id =&gt;
    <span class="method">apply </span>(<span class="method">getUser</span>(id)) (user =&gt;
        <span class="method">getMiddleName</span>(user)
    )
);
</code></pre><p>It&#39;s a dense representation, but they are equivalent. Note that functions are called with a space between the name and opening parenthesis, this isn&#39;t common syntax but it&#39;s valid JavaScript. It&#39;s there to simulate &quot;call by juxtaposition&quot; syntax in languages like Haskell, where functions are called with <code>f x y z</code>. But instead of calling them like you normally would in JavaScript with <code>f(x)(y)(z)</code>, we call them with <code>f (x) (y) (z)</code>.</p><p>This functional version of blocks works by breaking them down into two parts:</p><pre><code lang="js"><span class="special">const </span><span class="global">middleName</span> = (() =&gt; {
    <span class="special">const </span><span class="global">id</span> = <span class="method">getId </span>();
    <span class="special">return</span> (() =&gt; {
        <span class="special">const </span><span class="global">user</span> = <span class="method">getUser </span>(id);
        <span class="special">return</span> <span class="method">getMiddleName </span>(user);
    })();
})();
</code></pre><p>Instead of having everything in the same block, we define a &quot;block&quot; simply as a value based on a variable. In the outer block, the <code>id</code> is the variable, and the value is a function of the <code>id</code>. In this case, the value is another block, where <code>user</code> is the variable and the value is a function of the user.</p><h2 id="null-everywhere">Null Everywhere</h2><p>Revisiting the previous example, the code might look like this:</p><pre><code lang="js"><span class="special">const </span><span class="global">apply</span> = x =&gt; f =&gt; <span class="method">f </span>(x);
<span class="special">const </span><span class="global">middleName</span> = <span class="method">apply </span>(<span class="method">getId</span>()) (id =&gt;
    <span class="method">apply </span>(<span class="method">getUser</span>(id)) (user =&gt;
        <span class="method">getMiddleName</span>(user)
    )
);
</code></pre><p>It&#39;s clean enough, right? Now imagine if <code>id</code> could be <code>null</code>, <code>user</code> could be <code>null</code>, or <code>middleName</code> could be <code>null</code>. The utility functions will all end up looking like this:</p><pre><code lang="js"><span class="comment">// Simulate the fetching of an ID.</span>
<span class="special">const </span><span class="global">getId</span> = () =&gt; {
    <span class="special">const </span><span class="global">random</span> = Math.<span class="method">floor</span>(Math.<span class="method">random</span>() * <span class="global">1000</span>);

    <span class="special">return</span> random &lt; <span class="global">700</span> ? random : <span class="global">null</span>;
};

<span class="comment">// Simulate the fetching of a user.</span>
<span class="special">const </span><span class="global">getUser</span> = id =&gt; {
    <span class="special">if</span> (id === <span class="global">null</span>) {
        <span class="special">return</span> <span class="global">null</span>;
    } <span class="special">else</span> {
        <span class="special">return</span> {
            first: <span class="string">&quot;John&quot;</span>,
            last: <span class="string">&quot;Doe&quot;</span>,
            middle: Math.<span class="method">random</span>() &lt; <span class="global">0.7</span> ? <span class="string">&quot;Bob&quot;</span> : <span class="global">null</span>
        };
    }
};

<span class="comment">// Simulate the fetching of a middle name.</span>
<span class="special">const </span><span class="global">getMiddleName</span> = user =&gt; {
    <span class="special">if</span> (user.middle === <span class="global">null</span>) {
        <span class="special">return</span> <span class="global">null</span>;
    } <span class="special">else</span> {
        <span class="special">return</span> user.middle;
    }
};
</code></pre><p>Every utility function has to check and handle <code>null</code> values, and has the possibility of returning <code>null</code> as well. But what if we checked for it automatically?</p><p>Once again, the functional version of the block would look like this:</p><pre><code lang="js"><span class="special">const </span><span class="global">apply</span> = x =&gt; f =&gt; <span class="method">f </span>(x);
<span class="special">const </span><span class="global">middleName</span> = <span class="method">apply </span>(<span class="method">getId</span>()) (id =&gt;
    <span class="method">apply </span>(<span class="method">getUser</span>(id)) (user =&gt;
        <span class="method">getMiddleName</span>(user)
    )
);
</code></pre><p>Looking at this, we can find a pattern: every <code>apply</code> takes a nullable value as input and applies it to a function. This function always returns another nullable value, and by extension <code>apply</code> needs to also return a nullable value because it may be used within the function itself. Instead of handling <code>null</code> within each function, <code>apply</code> can handle it.</p><pre><code lang="js"><span class="special">const </span><span class="global">apply</span> = x =&gt; f =&gt; x === <span class="global">null</span> ? <span class="global">null</span> : <span class="method">f </span>(x);
</code></pre><p>Since the inputs can be <code>null</code>, it checks and returns <code>null</code> whenever the input is <code>null</code>. If not, it passes <code>x</code> to the function. It treats the function as a black box that can return anything, but assumes that it takes a non-null value as input. Since <code>apply</code> itself will have a nullable value as input, it handles the <code>null</code> case and then passes any real values into the function. Now, the full the code will look like this:</p><pre><code lang="js"><span class="comment">// Simulate the fetching of an ID.</span>
<span class="special">const </span><span class="global">getId</span> = () =&gt; {
    <span class="special">const </span><span class="global">random</span> = Math.<span class="method">floor</span>(Math.<span class="method">random</span>() * <span class="global">1000</span>);

    <span class="special">return</span> random &lt; <span class="global">700</span> ? random : <span class="global">null</span>;
};

<span class="comment">// Simulate the fetching of a user.</span>
<span class="special">const </span><span class="global">getUser</span> = id =&gt; ({
    first: <span class="string">&quot;John&quot;</span>,
    last: <span class="string">&quot;Doe&quot;</span>,
    middle: Math.<span class="method">random</span>() &lt; <span class="global">0.7</span> ? <span class="string">&quot;Bob&quot;</span> : <span class="global">null</span>
});

<span class="comment">// Simulate the fetching of a middle name.</span>
<span class="special">const </span><span class="global">getMiddleName</span> = user =&gt; user.middle;

<span class="comment">// Get the middle name, <span class="special">if</span> it exists.</span>
<span class="special">const </span><span class="global">apply</span> = x =&gt; f =&gt; x === <span class="global">null</span> ? <span class="global">null</span> : <span class="method">f </span>(x);
<span class="special">const </span><span class="global">middleName</span> = <span class="method">apply </span>(<span class="method">getId</span>()) (id =&gt;
    <span class="method">apply </span>(<span class="method">getUser</span>(id)) (user =&gt;
        <span class="method">getMiddleName</span>(user)
    )
);

console.<span class="method">log</span>(middleName);
<span class="comment">// <span class="global">49</span>% =&gt; <span class="string">&quot;Bob&quot;</span>, <span class="global">51</span>% =&gt; <span class="global">null</span></span>
</code></pre><h2 id="logging">Logging</h2><p>Keeping the same example, let&#39;s say we want to keep track of log messages. In a functional language, you can&#39;t modify a global variable to keep track of all of the messages. Instead, each function can return an output along with a log message.</p><pre><code lang="js"><span class="special">const </span><span class="global">getId</span> = () =&gt; [<span class="global">7</span>, <span class="string">&quot;Got an id of <span class="global">7</span>.&quot;</span>];
<span class="special">const </span><span class="global">getUser</span> = id =&gt; [{
    first: <span class="string">&quot;John&quot;</span>,
    last: <span class="string">&quot;Doe&quot;</span>,
    middle: <span class="string">&quot;Bob&quot;</span>
}, id[<span class="global">1</span>] + <span class="string">&quot; Got a user with name John Bob Doe.&quot;</span>];
<span class="special">const </span><span class="global">getMiddleName</span> = user =&gt; [user[<span class="global">0</span>].middle, user[<span class="global">1</span>] + <span class="string">&quot; Got the middle name of a user.&quot;</span>];

<span class="special">const </span><span class="global">apply</span> = x =&gt; f =&gt; <span class="method">f </span>(x);
<span class="special">const </span><span class="global">middleName</span> = <span class="method">apply </span>(<span class="method">getId</span>()) (id =&gt;
    <span class="method">apply </span>(<span class="method">getUser</span>(id)) (user =&gt;
        <span class="method">getMiddleName</span>(user)
    )
);
</code></pre><p>This is messy, and we had to modify the utility functions in order to handle the incoming array input. Instead, we can change the <code>apply</code> function to propagate the log for us. In this case, the inputs to <code>apply</code> always have the structure of <code>[output, log]</code>. However, we want the function <code>f</code> to only receive the output. Unlike the previous example, we will now assume that <code>f</code> returns the same <code>[output, log]</code> pair. Since <code>f</code> can return the output of <em>another</em> <code>apply</code>, we need to return the same type from <code>apply</code>.</p><pre><code lang="js"><span class="special">const </span><span class="global">apply</span> = x =&gt; f =&gt; {
    <span class="special">const </span><span class="global">result</span> = <span class="method">f </span>(x[<span class="global">0</span>]);
    <span class="special">return</span> [result[<span class="global">0</span>], x[<span class="global">1</span>] + <span class="string">&quot; &quot;</span> + result[<span class="global">1</span>]];
};
</code></pre><p>Since everything has the same array type, we take it as an input. Instead of passing the log to the function though, we only pass the output of the value <code>x[0]</code> to the function <code>f</code>. We assume that this function will return its own output and log. Since this function can return the output of <code>apply</code>, we return a new pair with the function output along with the combined logs.</p><p>The full code will then be much simpler, and doesn&#39;t include anything related to the previous log message in the utility functions:</p><pre><code lang="js"><span class="comment">// Get various data from a user.</span>
<span class="special">const </span><span class="global">getId</span> = () =&gt; [<span class="global">7</span>, <span class="string">&quot;Got an id of <span class="global">7</span>.&quot;</span>];
<span class="special">const </span><span class="global">getUser</span> = id =&gt; [{
    first: <span class="string">&quot;John&quot;</span>,
    last: <span class="string">&quot;Doe&quot;</span>,
    middle: <span class="string">&quot;Bob&quot;</span>
}, <span class="string">&quot;Got a user with name John Bob Doe.&quot;</span>];
<span class="special">const </span><span class="global">getMiddleName</span> = user =&gt; [user.middle, <span class="string">&quot;Got the middle name of a user.&quot;</span>];

<span class="comment">// Get the middle name along with logs.</span>
<span class="special">const </span><span class="global">apply</span> = x =&gt; f =&gt; {
    <span class="special">const </span><span class="global">result</span> = <span class="method">f </span>(x[<span class="global">0</span>]);
    <span class="special">return</span> [result[<span class="global">0</span>], x[<span class="global">1</span>] + <span class="string">&quot; &quot;</span> + result[<span class="global">1</span>]];
};
<span class="special">const </span><span class="global">middleName</span> = <span class="method">apply </span>(<span class="method">getId</span>()) (id =&gt;
    <span class="method">apply </span>(<span class="method">getUser</span>(id)) (user =&gt;
        <span class="method">getMiddleName</span>(user)
    )
);

console.<span class="method">log</span>(middleName);
<span class="comment">// =&gt; [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Got an id of <span class="global">7</span>. Got a user with name John Bob Doe. Got the middle name of a user.&quot;</span>]</span>
</code></pre><h2 id="global-environment">Global Environment</h2><p>Let&#39;s say we have a global object fetched from somewhere, and it holds data for a user.</p><pre><code lang="js">{
    id: <span class="global">7</span>,
    first: <span class="string">&quot;John&quot;</span>,
    last: <span class="string">&quot;Doe&quot;</span>
}
</code></pre><p>Along with that, we have a calculation based on this environment.</p><pre><code lang="js"><span class="special">const </span><span class="global">getInitials</span> = environment =&gt; environment.first[<span class="global">0</span>] + environment.last[<span class="global">0</span>];
<span class="special">const </span><span class="global">getName</span> = initials =&gt; environment =&gt; <span class="string">`${initials} ${environment.first} ${environment.last}`</span>;
<span class="special">const </span><span class="global">getIdentity</span> = name =&gt; environment =&gt; environment.id.<span class="method">toString</span>() + <span class="string">&quot; &quot;</span> + name;

<span class="special">const </span><span class="global">apply</span> = x =&gt; f =&gt; <span class="method">f </span>(x);
<span class="special">const </span><span class="global">identity</span> = <span class="method">apply </span>(<span class="method">getInitials </span>(environment)) (initials =&gt;
    <span class="method">apply </span>(<span class="method">getName </span>(initials) (environment)) (name =&gt;
        <span class="method">getIdentity </span>(name) (environment)
    )
);
</code></pre><p>In this case, every single function requires the <code>environment</code> as an input. What if we made that implicit?</p><pre><code lang="js"><span class="special">const </span><span class="global">getInitials</span> = environment =&gt; environment.first[<span class="global">0</span>] + environment.last[<span class="global">0</span>];
<span class="special">const </span><span class="global">getName</span> = initials =&gt; environment =&gt; <span class="string">`${<span class="method">initials </span>(environment)} ${environment.first} ${environment.last}`</span>;
<span class="special">const </span><span class="global">getIdentity</span> = name =&gt; environment =&gt; environment.id.<span class="method">toString</span>() + <span class="string">&quot; &quot;</span> + <span class="method">name </span>(environment);

<span class="special">const </span><span class="global">apply</span> = x =&gt; f =&gt; <span class="method">f </span>(x);
<span class="special">const </span><span class="global">identity</span> = <span class="method">apply </span>(getInitials) (initials =&gt;
    <span class="method">apply </span>(<span class="method">getName </span>(initials)) (name =&gt;
        <span class="method">getIdentity </span>(name)
    )
);
</code></pre><p>It looks nicer, but the utility functions had to change. They now have to call their first argument with the environment in order to get their true value. However, <code>apply</code> can make some assumptions in this case. It can assume that every input is a <em>function of the environment</em>, and every function takes a value and returns another function of the environment.</p><p>We can solve this problem using <code>apply</code>. Every input <code>x</code> is a function of the environment, but it would be nice if given function <code>f</code> could expect the <em>output</em> of <code>x</code>. How can we get the output out of <code>x</code>? We need to pass it the environment, so we can return a <em>new function</em> that depends on the environment and calls <code>x</code>. Now it can pass the output to <code>f</code> as it expects. Since <code>f</code> is also a function of the environment, we can call it with our given environment and finally return the result.</p><pre><code lang="js"><span class="special">const </span><span class="global">apply</span> = x =&gt; f =&gt; environment =&gt; <span class="method">f </span>(<span class="method">x </span>(environment)) (environment);
</code></pre><p>It&#39;s a little confusing, but <code>apply</code> uses the assumptions to its advantage. First of all, it returns a function of the environment. This function applies the environment to the input <code>x</code>, and passes it to <code>f</code>. Since we assume <code>f</code> returns another function of the environment, we apply it with the given environment <em>again</em> and return its output.</p><p>With that, the final code looks like:</p><pre><code lang="js"><span class="comment">// Utility functions to <span class="special">return</span> calculations based on an environment.</span>
<span class="special">const </span><span class="global">getInitials</span> = environment =&gt; environment.first[<span class="global">0</span>] + environment.last[<span class="global">0</span>];
<span class="special">const </span><span class="global">getName</span> = initials =&gt; environment =&gt; <span class="string">`${initials} ${environment.first} ${environment.last}`</span>;
<span class="special">const </span><span class="global">getIdentity</span> = name =&gt; environment =&gt; environment.id.<span class="method">toString</span>() + <span class="string">&quot; &quot;</span> + name;

<span class="comment">// Get the identity of the environment user.</span>
<span class="special">const </span><span class="global">apply</span> = x =&gt; f =&gt; environment =&gt; <span class="method">f </span>(<span class="method">x </span>(environment)) (environment);
<span class="special">const </span><span class="global">identity</span> = <span class="method">apply </span>(getInitials) (initials =&gt;
    <span class="method">apply </span>(<span class="method">getName </span>(initials)) (name =&gt;
        <span class="method">getIdentity </span>(name)
    )
);

<span class="comment">// Since <span class="string">`identity`</span> is a <span class="special">function</span> of an environment, we can pass it any environment.</span>
console.<span class="method">log</span>(<span class="method">identity </span>({
    id: <span class="global">7</span>,
    first: <span class="string">&quot;John&quot;</span>,
    last: <span class="string">&quot;Doe&quot;</span>
}));
<span class="comment">// =&gt; <span class="global">7</span> JD John Doe</span>
</code></pre><h2 id="passing-state">Passing State</h2><p>Let&#39;s say we have a state for holding the seed of a random number generator.</p><pre><code lang="js"><span class="global">7</span>
</code></pre><p>In pure functional languages, there is no concept of mutation, only pure functions. However, for things like random number generation, there is often a seed that is kept track of as state. It needs to be sent around so that the next number and seed can be generated from it. We can write a block like this:</p><pre><code lang="js"><span class="special">const </span><span class="global">getRandom</span> = state =&gt; {
    <span class="special">const </span><span class="global">result</span> = <span class="global">7</span> * state + <span class="global">7</span>;
    <span class="special">return</span> [result % <span class="global">100</span>, result];
};

<span class="special">const </span><span class="global">getSum</span> = x =&gt; y =&gt; state =&gt; {
    <span class="special">const </span><span class="global">xResult</span> = <span class="method">x </span>(state);
    <span class="special">const </span><span class="global">yResult</span> = <span class="method">y </span>(xResult[<span class="global">1</span>]);
    <span class="special">return</span> [xResult[<span class="global">0</span>] + yResult[<span class="global">0</span>], yResult[<span class="global">1</span>]];
};

<span class="special">const </span><span class="global">apply</span> = x =&gt; f =&gt; <span class="method">f </span>(x);
<span class="special">const </span><span class="global">sum</span> = <span class="method">apply </span>(getRandom) (random1 =&gt;
    <span class="method">apply </span>(getRandom) (random2 =&gt;
        <span class="method">getSum </span>(random1) (random2)
    )
);
</code></pre><p>In this example, every value is a function of state that returns and output along with new state. It&#39;s not the best code though, because <code>getSum</code> has to call both of its arguments with the state in order to get their value, then it has to correctly manage the latest state and return it.</p><p>However, <code>apply</code> can assume that every input is a <em>function of state that returns output and new state</em>. It can also assume that the function takes only an output value and returns another function of state.</p><p>Using these assumptions, it would be nice if the function <code>f</code> could expect only the output portion of <code>x</code>&#39;s return value. To get <code>x</code>&#39;s output, we need to call it with the state, so we can return a new function of state. Within this function, we can pass <code>x</code> the state and get an output along with new state. Now we can supply <code>f</code> the output, and since <code>f</code> returns a function of state, we can call it again with the new state returned by <code>x</code>. Finally, we can return this result.</p><pre><code lang="js"><span class="special">const </span><span class="global">apply</span> = x =&gt; f =&gt; state =&gt; {
    <span class="special">const </span><span class="global">result</span> = <span class="method">x </span>(state);
    <span class="special">return</span> <span class="method">f </span>(result[<span class="global">0</span>]) (result[<span class="global">1</span>]);
};
</code></pre><p>It&#39;s elegant, but dense. Since the output of the given function is assumed to be another function of state, <code>apply</code> starts by returning a new function of state. This function calls the input <code>x</code> with the state to get an output along with new state. It passes the output to <code>f</code>, which expects just the output of <code>x</code> as its input. Since <code>f</code> returns another function of state, it calls it again with the new state returned by <code>x</code>.</p><p>The full code looks like:</p><pre><code lang="js"><span class="comment">// Utility functions <span class="special">for</span> number manipulation.</span>
<span class="special">const </span><span class="global">getRandom</span> = state =&gt; {
    <span class="special">const </span><span class="global">result</span> = <span class="global">7</span> * state + <span class="global">7</span>;
    console.<span class="method">log</span>(<span class="string">&quot;Random number: &quot;</span> + (result % <span class="global">100</span>)); <span class="comment">// Log random numbers <span class="special">for</span> debugging.</span>
    <span class="special">return</span> [result % <span class="global">100</span>, result];
};

<span class="special">const </span><span class="global">getSum</span> = x =&gt; y =&gt; state =&gt; [x + y, state];

<span class="comment">// Generate the sum of two random numbers.</span>
<span class="special">const </span><span class="global">apply</span> = x =&gt; f =&gt; state =&gt; {
    <span class="special">const </span><span class="global">result</span> = <span class="method">x </span>(state);
    <span class="special">return</span> <span class="method">f </span>(result[<span class="global">0</span>]) (result[<span class="global">1</span>]);
};

<span class="special">const </span><span class="global">sum</span> = <span class="method">apply </span>(getRandom) (random1 =&gt;
    <span class="method">apply </span>(getRandom) (random2 =&gt;
        <span class="method">getSum </span>(random1) (random2)
    )
);

console.<span class="method">log</span>(<span class="method">sum </span>(<span class="global">7</span>));
<span class="comment">// =&gt; Random number: <span class="global">56</span></span>
<span class="comment">// =&gt; Random number: <span class="global">99</span></span>
<span class="comment">// =&gt; [<span class="global">155</span>, <span class="global">399</span>]</span>
</code></pre><h2 id="conclusion">Conclusion</h2><p>You&#39;ll notice how I didn&#39;t mention monads throughout the examples. That&#39;s because the code was just written using a natural abstraction, and that abstraction was the <code>apply</code> function, which applied functions that made up do-blocks in special ways. The truth is, we just implemented four different monads:</p><ol><li>Null Everywhere - <code>Maybe</code> Monad - Assumed <code>x: nullable</code> and <code>f: nullable -&gt; any</code></li><li>Logging - <code>Writer</code> Monad - Assumed <code>x: [any, string]</code> and <code>f: any -&gt; [any, string]</code></li><li>Global Environment - <code>Reader</code> Monad - Assumed <code>x: environment -&gt; any</code> and <code>f: any -&gt; environment -&gt; any</code></li><li>Passing State - <code>State</code> Monad - Assumed <code>x: state -&gt; [any, state]</code> and <code>f: any -&gt; state -&gt; [any, state]</code></li></ol><p>The monad itself is a triple of a type constructor, a type converter, and a type combinator.</p><p>The type constructor is just a way of defining the type of value that stayed constant throughout the do-blocks. For example, the <code>Maybe</code> monad type constructor returns <code>T | null</code>, and the <code>State</code> monad type constructor returns <code>state -&gt; [output, state]</code>.</p><p>The type converter is a way of creating a &quot;unit&quot; value of the type. For example, the <code>Writer</code> monad type converter is <code>const unit = x =&gt; [x, &quot;&quot;]</code>. It wraps any value within a <code>Writer</code> type that includes the value along with an empty log. We didn&#39;t cover these much to reduce the complexity of getting started.</p><p>The type combinator is another name for our <code>apply</code> function, with a signature of <code>m -&gt; (any -&gt; m) -&gt; m</code>. It basically means that it accepts an input with the type constructor of a monad and a function that returns the same type. Using these two, it returns an output with the same type. This is commonly named <code>bind</code>.</p><p>Together, the three of these form a monad. Think of it like this: a do-block can be split into recursive <code>apply</code> calls. If we make assumptions that every input is a certain type, then <code>apply</code> can transform the input before applying it to the function. If we make assumptions that the function outputs a certain type, then <code>apply</code> can transform the output of the function to combine it with the original input. Basically, it can return whatever it wants using the given input and function. To make this even more useful, <code>apply</code> can return the same type that it assumes the function will return. This allows the function to use <code>apply</code> within itself.</p><p>Some other great resources on monads include:</p><ul><li><a href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">You Could Have Invented Monads! (And Maybe You Already Have.)</a></li><li><a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures</a></li><li><a href="http://adit.io/posts/2013-06-10-three-useful-monads.html">Three Useful Monads</a></li><li><a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">Monad (functional programming)</a></li></ul><p>In the end, the monad is just an abstraction that has access to the inner workings of block expressions, giving it control over how things flow from input to function.</p></div><footer><a href="https://kabir.sh">Portfolio</a> <a href="https://blog.kabir.sh">Blog</a> <a href="https://twitter.com/kbrshah">Twitter</a> <a href="https://github.com/kbrsh">GitHub</a></footer></body></html>