<!doctype html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Optimal Virtual DOM | Kabir Shah's blog on design, the web, servers, databases, systems, algorithms, artificial intelligence, cryptography, and ideas."><meta name="author" content="Kabir Shah"><title>Optimal Virtual DOM | Kabir Shah</title><link rel="shortcut icon" href="../img/logo-fill.png"/><link rel="alternate" type="application/json" title="Kabir Shah" href="/feed.json"/><link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400,700|Inconsolata&display=swap" rel="stylesheet"/><link rel="stylesheet" type="text/css" href="../css/lib/grain.css"/><link rel="stylesheet" type="text/css" href="../css/styles.css"/><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-70792533-7","auto"),ga("send","pageview")</script></head><body><a href="../" id="back"><svg width="37" height="24" viewBox="0 0 37 24" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>Arrow</title><path id="back-arrow" d="M36.0607 1.06066c.5857-.585786.5857-1.535534 0-2.12132l-9.546-9.54594c-.5858-.5858-1.5355-.5858-2.1213 0-.5858.5858-.5858 1.53553 0 2.12132L32.8787 0l-8.4853 8.48528c-.5858.58579-.5858 1.53552 0 2.12132.5858.5858 1.5355.5858 2.1213 0l9.546-9.54594zM0 1.5h35v-3H0v3z" transform="rotate(180 18.5 6)" fill="#888"/></svg></a><div class="container"><div class="head"><div class="head-title"><h1>Optimal Virtual DOM</h1></div><p>December 5, 2019</p></div><div class="post"><p>The virtual DOM is an idea that stems from functional programming in user interfaces. On every update new UI trees replace the current one. The problem arises, however, when this idea of an immutable, declarative view is applied in the browser.</p><p>The DOM is inherently imperative; it is updated through mutating method calls. A virtual DOM bridges the gap between declarative and imperative environments, allowing users to create lightweight trees while mutating the DOM under the hood.</p><p>Still, a fast implementation of the virtual DOM can be a difficult task. As I&#39;ve worked on <a href="https://kbrsh.github.io/moon">Moon</a>, I&#39;ve tried many different approaches to the diffing algorithm, with the most <a href="https://github.com/kbrsh/moon/commit/e7a7cd9ab427be89cb7efee70df86dfe0401d770">recent revision</a> being explained here. It&#39;s very fast on benchmarks because it sticks to one principle: avoiding the DOM as much as possible.</p><p>There are many ways to approach a virtual DOM implementation, each building on top of the previous one to gain better performance.</p><h2 id="replace">Replace</h2><p>The simplest way of implementing a virtual DOM is based on replacing elements. A new element created from a virtual node replaces the old one.</p><pre><code lang="js">node.parentNode.<span class="method">replaceChild</span>(<span class="method">nodeFromVNode</span>(vnode), node);
</code></pre><p>This is wasteful because the DOM was not designed for large numbers of element creation, preferring granular method calls instead.</p><h2 id="dom-diff">DOM Diff</h2><p>Transforming the DOM through a diff and patch between a virtual node and the DOM allows for more precise changes. For example, updating a <code>className</code> property may check against the current state of the DOM.</p><pre><code lang="js"><span class="special">if</span> (node.className !== vnode.className) {
    node.className = vnode.className;
}
</code></pre><p>Even so, <em>reading</em> the DOM is bad for performance. Virtual node object property access is much faster.</p><h2 id="virtual-dom-diff">Virtual DOM Diff</h2><p>Instead of diffing against the DOM, the previous virtual DOM can be stored and used instead.</p><pre><code lang="js"><span class="special">if</span> (vnodeOld.className !== vnodeNew.className) {
    node.className = vnodeNew.className;
}
</code></pre><p>Now, the DOM is accessed only when it is necessary â€” to modify it. However, when diffing against children, this means accessing <code>childNodes</code>:</p><pre><code lang="js"><span class="special">for</span> (<span class="special">let</span> i = <span class="global">0</span>; i &lt; length; i++) {
    <span class="special">const </span><span class="global">vchildOld</span> = vnodeOld.children[i];
    <span class="special">const </span><span class="global">vchildNew</span> = vnodeNew.children[i];

    <span class="special">if</span> (vchildOld !== vchildNew) {
        <span class="comment">// Assume that <span class="string">`diff`</span> takes an old virtual node, <span class="special">new</span> virtual node, and a</span>
        <span class="comment">// DOM element to patch.</span>
        <span class="method">diff</span>(vchildOld, vchildNew, node.childNodes[i]);
    }
}
</code></pre><p>Even a loop using <code>firstChild</code> and <code>nextSibling</code> would still access the DOM on every iteration. This is slow. Moon gets around this by keeping track of children in a separate property on every DOM element called <code>MoonChildren</code>.</p><pre><code lang="js"><span class="special">for</span> (<span class="special">let</span> i = <span class="global">0</span>; i &lt; length; i++) {
    <span class="special">const </span><span class="global">vchildOld</span> = vnodeOld.children[i];
    <span class="special">const </span><span class="global">vchildNew</span> = vnodeNew.children[i];

    <span class="special">if</span> (vchildOld !== vchildNew) {
        <span class="method">diff</span>(vchildOld, vchildNew, node.MoonChildren[i]);
    }
}
</code></pre><h2 id="conclusion">Conclusion</h2><p>A diff between virtual nodes, accessing the DOM only for modification, is the fastest approach to a virtual DOM. It avoids the DOM as much as possible, favoring plain JavaScript objects instead, making reading and writing much cheaper. Combined with using constructors for virtual nodes, storing events on DOM nodes, and using a purely functional design, Moon&#39;s view driver is faster than ever before.</p></div></div><footer><a href="https://kabir.sh">Portfolio</a> <a href="https://blog.kabir.sh">Blog</a> <a href="https://twitter.com/kbrshah">Twitter</a> <a href="https://github.com/kbrsh">GitHub</a></footer></body></html>